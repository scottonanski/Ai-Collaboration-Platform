import { MessagePart } from '../collaborationTypes';

// Regular expression to find code blocks (complete or incomplete)
// Group 1: Language (optional)
// Group 2: Code content (complete block)
// Group 3: Language (optional, incomplete block)
// Group 4: Code content (incomplete block)
const codeBlockRegex = /```(\w+)?\n?([\s\S]*?)```|```(\w+)?\n?([\s\S]*)$/g;

export function parseBotMessage(message: string): MessagePart[] {
  const parts: MessagePart[] = [];
  let lastIndex = 0;
  let match;

  // Reset regex state
  codeBlockRegex.lastIndex = 0;

  while ((match = codeBlockRegex.exec(message)) !== null) {
    const fullMatch = match[0];
    const startIndex = match.index;

    // Add preceding text part if any
    if (startIndex > lastIndex) {
      const textContent = message.substring(lastIndex, startIndex);
      if (textContent.trim()) {
        parts.push({ type: 'text', content: textContent });
      }
    }

    // Check if it's a complete or incomplete code block
    if (match[2] !== undefined) { // Complete code block (Group 2 has content)
      parts.push({
        type: 'code',
        language: match[1] || '',
        code: match[2].trimEnd(), // Trim trailing whitespace/newlines from code
      });
    } else if (match[4] !== undefined) { // Incomplete code block (Group 4 has content)
      parts.push({
        type: 'incompleteCode',
        language: match[3] || '',
        code: match[4],
      });
    }

    lastIndex = startIndex + fullMatch.length;
  }

  // Add remaining text part if any
  if (lastIndex < message.length) {
    const textContent = message.substring(lastIndex);
    if (textContent.trim() || parts.length === 0) { // Add if not empty or if it's the only content
        parts.push({ type: 'text', content: textContent });
    }
  }

  // If the message is empty or only whitespace, ensure at least one empty text part
  if (parts.length === 0 && message.trim().length === 0) {
      parts.push({ type: 'text', content: message });
  }

  return parts;
}

// Helper function remains the same if needed elsewhere, but ChatMessage won't use it directly for paragraphs
export function groupIntoParagraphs(parts: MessagePart[]): MessagePart[][] {
    const paragraphs: MessagePart[][] = [];
    let currentParagraph: MessagePart[] = [];

    parts.forEach((part, index) => {
        if (part.type === 'code' || part.type === 'incompleteCode') {
            // If there's content in the current paragraph, push it
            if (currentParagraph.length > 0) {
                paragraphs.push([...currentParagraph]);
                currentParagraph = [];
            }
            // Push the code block as its own paragraph
            paragraphs.push([part]);
        } else {
            // Add text parts to the current paragraph
            // Split text content by double newlines to respect paragraph breaks in markdown
            const textParagraphs = part.content.split(/\n\s*\n/);
            textParagraphs.forEach((textPara: string, paraIndex: number) => {
                if (textPara.trim()) {
                    currentParagraph.push({ type: 'text', content: textPara });
                }
                // If this is not the last text paragraph generated by the split,
                // and there are more parts or this isn't the last split part,
                // it signifies a paragraph break, so push the current paragraph.
                if (paraIndex < textParagraphs.length - 1) {
                    if (currentParagraph.length > 0) {
                        paragraphs.push([...currentParagraph]);
                        currentParagraph = [];
                    }
                }
            });
        }

        // If it's the last part and there's content in the current paragraph, push it
        if (index === parts.length - 1 && currentParagraph.length > 0) {
            paragraphs.push([...currentParagraph]);
        }
    });

    // If the input was empty or only whitespace, ensure one paragraph with one empty text part
    if (parts.length === 1 && parts[0].type === 'text' && parts[0].content.trim().length === 0 && paragraphs.length === 0) {
        paragraphs.push([{ type: 'text', content: parts[0].content }]);
    }

    return paragraphs;
}